# 9장 코드 삭제의 미학

이번장에서 다룰 내용

- 코드가 개발속도를 어떻게 늦추는지 이해하기
- 우발적인 낭비를 방지하기 위한 한계 설정하기
- 스트랭글러 무화과 패턴으로 전환처리하기
- 스파이크 및 스태빌라이즈 패턴으로 낭비 최소화하기
- 도움이 되지 않는 모든 것을 삭제하기

### 코드 삭제

- 코드는 꾸준히 이자를 내야하는 부채와 같음. (=필요악)
- 코드는 생산비용이 비싸다
- `매몰 비용의 오류`: 우리가 시간이나 노력을 들였기때문에 어떤 것에 가치를 부여하는 것
- 가치는 투자 자체에서 나오는 것이 아니라, 투자의 결과에서 나옴
- 코드는 적은 것이 더 낫다

### 다음 시대는 코드를 지우는 시대일 것이다

- 주류 프로그래밍의 큰 도약이라고 생각되는 것 요약
  - 컴퓨터로 추상화없는 계산 수헹
  - 컴퓨터가 순수한 계산 대신 기호로 작업
  - 컴파일러 발명 - 제어 연산자 사용가능
  - 데이터 추상화, 포인터와 참조
  - 디자인 패턴
  - 리팩터링 패턴
  - 마이크로서비스 아키텍처
- 이 다음의 과제는 `코드 삭제`라고 생각함

### 복잡성을 제거하기 위한 코드 삭제

- 기능을 추가하고, 테스트를 수행하며 더 많은 코너케이스를 처리함에 따라 시간이 지날수록 시스템은 성장함
- 구현할 때, 시스템이 어떻게 동작하는지에 대한 멘탈모형을 구축한 다음, 이에 영향을 미치도록 변경해야함
- 더 큰 코드베이스는 커플링으로 인해 더 복잡한 모델이 필요하고, 더 큰 유틸리티 라이브러리가 필요함
- `도메인 복잡성`: 도메인이 기본적으로 가지고 있는 것. 우리가 해결하는 문제는 본질적으로 복잡함
- `부수적 복잡성`: 도메인에서 요구하지 않았지만, 우연히 추가된 모든 복잡성
- 부수적 복잡성은 일반적으로 기술부채의 동의어로 사용됨 (필자는 더 세밀한 용어를 사용하는 것이 유익하다고 생각함)

#### 경험 부족으로 인한 기술적 무지

- 결합을 추가하기 않고도 문제를 해결할 수 있는 기술이 부족해서 발생
- 기술적 우수성과 우수한 설계에 지속적으로 주의를 기울이면 민첩성이 향상됨
- 책, 블로그, 컨퍼런스, 튜토리얼, 공동 프로그래밍 (페어프로그래밍, 앙상블프로그래밍 등) 등을 통해 지식을 공유하고 연습해야함

#### 시간 압박으로 인한 기술적 낭비

- 코드에서 잘못된 결정을 내림으로써 아키텍처가 좋지 않은 결과를 초래하는 것
- 주로 시간 압박에서 비롯됨
- 테스트나 리팩터링을 건너뛰거나 프로세스를 우회함
- 해결책은 개발자에게 모범사례를 건너뛸 기회가 전혀 없게 하는 것

#### 환경에 따른 기술적 부채

- 일시적으로 차선의 해결책을 선택해서 이익을 얻는 것
- 전략적인 결정이며, 만료일이 있는 한 본질적으로 잘못된 것이 없음

#### 성장에 따른 기술적 장애물

- 개발을 더디게 만드는 모든 것
- 문서, 테스트, 모든 코드 등
- 자동화된 테스트는 테스트 코드를 변경해야하므로 코드를 변경하기 어렵게함
- 문서는 변경될 때 반드시 업데이트해야 하기 때문에 개발 속도를 늦춤
- 기술적 장애물은 무언가를 구축하는데 따르는 부작용
- 해결책은 더 이상 삭제할 것이 없을 때까지 가능한 많은 것을 삭제하는 것
- 사용하지 않거나 불필요한 기능, 코드, 문서, 위키 페이지, 테스트, 환경 설정 플래그, 인터페이스, 버전 관리 시스템의 브랜치 등을 모두 삭제하자

### 친밀도에 따른 코드 분류

- 최근에 개발한 코드가 가장 익숙함
- 자주 사용하는 라이브러리와 유틸리티에도 익숙함
- 그 외에 것들은 다시 배워야하기 때문에 유지보수 비용이 많이듦
- 친밀한 코드를 삭제하는 것이 이해를 먼저 해야하는 코드를 삭제하는 것보다 저렴하고 안전함
- 6주가 지나면 코드가 알 수 없는 범주로 빠르게 이동하면서 해당 코드와의 친밀도가 떨어지기 시작한다고 주장함

### 레거시 시스템에서의 코드 삭제

- 레거시 코드의 일반적 정의는 수정하기가 겁나는 코드
- `서커스 팩터` - 개발하는 동안 얼마나 많은 사람이 서커스에 합뷰해야하는자
- ex) 이 시스템을 배포하는 방법은 A 밖에 모르는 경우 <- 서커스 팩터가 있음
- 서커스 팩터를 잃는 순간 레거시 코드를 가지게됨
- 코드는 작동하겠지만, 그것을 편집하는 것은 불안하게됨

#### 스트랭글러 무화과나무 패턴

- 먼저 레거시 코드가 얼마나 사용되고 있는지 확인해야함
- 거의 사용되지 않는 경우 삭제할 수 있음
- 작은 부분만 많이 사용한다면 해당 부분만 수정하고 나머지는 제거
- 모든 것이 많이 사용된다면 코드에 익숙해져서 안넝적으로 만들어야함
- 레거시 코드의 각부분이 얼마나 호출되는지, 얼마나 호출이 성공했는지 알아야함
- `스트랭글러 무화과나무`처럼 숙주(레거시 시스템)를 감싸 궁극적으로 숙주 나무를 죽이는 패턴 사용
- 가장 많이 호출되는 부분은 거의 확실히 마이그레이션해야하고, 가장 적게 호출되는 부분은 높은 확률로 삭제
- 가장 적게 또는 항상 실패하는 코드를 비판적으로 평가해서 중요하거나 전략적 기능이 있는지 여부를 판단해야함
- 중요한 코드라면 코드에 익숙해져야함
  1. 해당 부분을 리팩터링해서 결합과 취약성을 제거하고 최신 코드로 분류하기
  2. 해당 부분을 다시 만들고 다시 만들어진 코드가 준비되면 게이트를 변경해서 새 버전으로 전환할 수 있음
- 일부 레거시 코드가 중요하지 않고 전략적이지 않은 경우 게이트에서 메서드 삭제
- 그리고 사용하지 않게된 코드는 삭제 후 컴파일하기 패턴으로 삭제

### 동결된 프로젝트에서 코드 삭제

- 코드 뿐 아니라 데이터베이스 테이블, 통합, 서비스 등 코드 밖의 많은 항목이 포함됨
- 원래 작성자가 프로젝트에 대해 잊어버리면 프로젝트가 존재하는지조차 발견하기 어려움
- 메인 브랜치에 그런 식으로 추가되고 사용하지 않는 코드가 있을 수 있음
- 이 코드는 레거시가 될 위험이 있음

#### 바람직한 결과를 기본값으로 설정

- 프로젝트가 코드베이스 외부에 영향을 미치지 않으면 메인 브랜치에서 코드를 되돌리고 별도의 브랜치에 넣기
  - 태그를 지정하고, 6주후에 태그를 삭제한다고 메모
  - 6주 안에 프로젝트를 사용하지 않으면 코드 삭제
- 코드 외적인 변경 사항이 포함되어 있으면 브랜치에는 넣지 못할 수 있음
  - 대신 제거할 모든 구성 요소를 프로젝트 관리 도구에 기록해두고 티켓을 6주 후로 예약
- 두 경우 모두 사람이 조치를 취하지 않으면 코드가 삭제됨. 실수로 기술적 장애물을 추가할 수 없으면 사람의 판단에 의해서만 추가될 수 있음

#### 스파이크와 스태빌라이즈(안정화)로 낭비 줄이기

- 스파이크 & 스태빌라이즈 패턴
- 프로젝트를 `스파이크`로 취급
- 모니터링을 포함시켜 이 코드가 얼마나 사용되고 있는지 알 수 있음
- 6주 후에 코드로 돌아가 코드가 얼마나 사용되었는지 확인함
- 많이 사용되었다면 재구현하고 고품질에 주의를 기울임 (자동화된 테스트, 리팩토링 등)
- 그렇지 않은 경우에는 삭제
- 동결된 프로젝트를 처리하는법
  1. 아직 동작하는가?
  2. 여전히 사용되고 있는가?
  3. 문서화되어 있는가?
  4. 롤백이 가능하도록 스크립트를 변경, 시간방비를 막기 위해 스파이크 및 스태빌라이즈 수행

### 버전 관리에서 브랜치 삭제

- Git의 경우 브랜치는 코드베이스 크기와 상관없이 바이트 단위로만 필요함 (비용이 저렴함)
- 브랜치의 목적
  1. hotfix 수정
  2. 커밋에 태그를 지정하여 release처럼 해당 위치로 되돌아감
  3. 다른 사람의 업무를 방해하지 않고 일하기 위해
- 1, 3번은 메인에 병합되면 삭제해야함
- 2번째는 Git의 기본 제공 방법을 사용해야함
- 주로 브랜치 삭제 옵션을 선택하는 것을 잊거나 언젠가는 필요할거라 생각해서 브랜치가 쌓이는 경우가 많음
- 브랜치는 메인 브랜치와 릴리즈 브랜치만 있어야함
- 그 외의 브랜치는 최적의 경우 며칠만 생존해있어야함
- 수명이 긴 브랜치를 가지고 있는 경우 비용이 많이들고 혼돈이 발생됨

#### 브랜치 제한으로 낭비 최소화

- 칸반 적용
- 진행 중인 작업 (WIP) 제한
- 팀이 진행할 수 있는 티켓 수에 대한 상한선이 정해져 있음
- 너무 많은 브랜치는 병목현상 문제와 맞아 떨어지기 때문에 브랜치 수에 제한을 도입할 수 있음
- 모든 사람이 동시에 작업할 수 있는 제한은 최소한 워크스테이션 수와 같아야함
- 워크스테이션은 독립적으로 작업할 수 있는 단위 (개발자 1명, 페어프로그래밍의 페어 1쌍 등)
- 브랜치 처리 방법
  1. 브랜치로 되돌려야 하는가?
  2. 삭제하는 것을 잊었는가?
  3. 차단되었는가?
  4. 정적 브랜치 대신 태그를 사용한다. 강제 정리를 위해 브랜치를 제한한다.

### 코드 문서 삭제

- 코드 문서는 위키 페이지, Javadoc, 설계 문서, 튜토리얼 등의 형태
- 문서는 3가지 조건을 충족해야함
  1. 관련성: 올바른 질문에 답해야함
  2. 정확성: 답은 정확해야함
  3. 발견 가능성: 답을 찾을 수 있어야함
- 문서를 유지보수 하는 것이 비용적으로 율하지 않을 수 있음

#### 지식을 문서화하는 방법을 결정하는 알고리즘

- 문서화하는 것이 의미가 있는지 여부를 결정할 때 절차
  1. 문서화 대상이 자주 바뀌면 문서화해서 얻을 수 있는 것이 없음
  2. 드물게 사용하는 경우 문서화
  3. 그렇지 않고 자동화할 수 있으면 자동화
  4. 그렇지 않으면 외우기
- 해결책은 문서 사용을 늘리는 것, 최신화를 자주하도록 만들어야함

### 테스트 코드 삭제

- 자동화된 테스트는 다양한 형태로 제공되며 문서보다 더 많은 속성을 가짐

#### 낙관적 테스트 삭제

- 실패할 수 없는 테스트
- 실패한 적이 없는 테스트를 절대 신뢰하지 말라
- 문제를 바로잡기 전에 테스트를 만들면 테스트를 통해 요건을 만족하는지 여부를 알 수 있지마느 바로 잡은 후에 테스트를 만들면 항상 통과하는 것만 보게됨

#### 비관적 테스트 삭제

- 항상 레드인 테스트를 한다면 테스트에서 오류가 발견되어도 경보 피로를 느껴 중대한 오류를 놓칠 수 있음

#### 불안정 테스트 수정 또는 삭제

- 항상 같은 결과를 내지 않는 예측할 수 없는 레드 또는 그린 테스트
- 테스트를 몇번 더 실행하는 것을 제외하면 어떤 조치도 끌어내지 않음

#### 복잡한 테스트를 제거하기 위한 코드 리팩터링

- 테스트가 코드보다 더 복잡하면 코드가 잘못된 것인지, 테스트가 잘못된 것인지 파악하기 어려움
- 리팩터링 노력은 테스트가 아니라 코드에 집중되어야함

#### 속도를 높이는 테스트 문화

- 종단 간의 테스트를 통해 특정 기능이 동작하는지 확인할 수 있음
- 하지만 느릴 수 있고, 테스트를 실행하는 빈도에 영향을 미침
- 느린 테스트와 빠른 테스트를 분리하고 가능한 자주 빠른 테스트를 지속적으로 실행하거나 느린 테스트의 실패 원인을 관찰하여 관련 없는 경우엔 제거해야함
- 자동화된 테스트를 처리하는 방법
  1. 낙관적이거나 불안정한가?
  2. 너무 복잡한가?
  3. 너무 느린가?
  4. 신뢰를 주지 않는 테스트는 삭제함. 벅집성 줄이기위해 코드를 리팩터링한다. 테스트 전문화로 속도를 높인다

### 설정 코드 삭제

- 실험적인 용도 인가? -> 가능한 빨리 제거
- 과도기적인 용도 인가? -> 스트랭글러 무화과나무 패턴으로 중앙 집중화한다
- 영구적인 것인가? -> 사용량을 늘리지 않으면 삭제한다

### 라이브러리 제거를 위한 코드 삭제

- 서드파티 라이브러리를 통해 많은 기능을 빠르고 저렴하게 얻을 수 있음
- 하지만 라이브러리를 업데이트해야하기때문에 코드를 수정해야할 일이 생길 수 있음
- 구성원이 해당 라이브러리에 최소한의 지식을 가지고 있어야하기때문에 인지부하가 더해짐
- 의존하는 기능이 더 이상 사용되지 않거나 제거되면 대체할 무언가를 만들어야함
- 때로는 우회코드를 만들거나, 라이브러리를 수정해야함

#### 외부 라이브러리에 대한 의존도 제한

- 고품질을 공급하는 공급업체의 라이브러리를 선택해서 해당 업체의 내부 품질 및 보안 요건을 믿는 것
- 뭔가를 자주하면 그것을 합리화하고 그것이 야기하는 고통을 줄이려는 더 많은 동기를 갖게됨
- -> 지속적인 통합, 전달 같은 프로세스의 배경
- 종속성을 가시적으로 만든 다음, 각 라이브러리가 개선 용도 인지, 중요 용도인지 분류함
- 개선용 라이브러리가 손상되면 제거하고 나중에 대체 라이브러리를 찾으면 됨

### 작동 중인 기능에서 코드 삭제

1.  충분히 사용되는가?
2.  유지비가 비싼가?
3.  개선할 수 있는가?
4.  작동 중인 기능에 대해서도 비판적으로 판단한다. 감당하지 못할 경우 제거한다. 비용을 줄이는 방법을 강구한다
