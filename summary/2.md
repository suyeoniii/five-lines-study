# 2장 리팩터링 깊게 들여다보기

- 가독성을 통한 의도 전달
- 유지보수성 개선을 위한 불변속성 지역화
- 개발 속도 향상을 위한, 추가를 통해 변경 가능하게 만들기
- 리팩터링의 일상 업무화

### 가독성 및 유지보수성 향상

> 리팩터링은 코드가 하는 일을 변경하지 않고 더 나은 코드를 만드는 것

1. 가독성

- **가독성**은 의도를 전달하기 위한 코드의 성질
- 가독성이 높으면 코드가 무슨 일을 하는지 파악하기 쉬움
- 코드에서 의도를 전달하는 방법 - 코딩 컨벤션 정하고 따르기, 주석 달기, 변수, 메서드, 클래스 및 파일 이름 지정, 공백 사용 등

읽기 힘든 코드의 예

```ts
function chackValue(str: boolean) {
  // 값 체크 <- 이름 반복 주석

  if (str !== false)
    // <- 읽기 어려운 이중 부정
    // 반환 <- 코드를 반복하는 의미 없는 주석
    return true;
  else; // 그렇지 않으면 <- 놓치기 쉬운 세미콜론과 사소한 주석
  --return str; // 오해의 소지가 있는 들여쓰기
}
```

2. 유지보수성

- 유지보수성은 얼마나 많은 후보를 조사해야 하는지를 나타내는 표현
- 조사 단계에 시간이 오래 걸린다는 것은 코드 유지보수성이 나쁘다는 징후이며 개선하기 위해 노력해야함
- 시스템에서 한 곳을 수정하면 다른 곳에 문제가 발생하는 경우 **취약하다(fragile)** 고 말함
- 취약성의 근원은 **전역 상태(global state)**
- 전역 상태는 우리가 고려하는 범위를 벗어난 것을 의미함. 메서드의 내부 변수가 전역 변수를 참조하는 상황
- 중괄호를 찾아서, 중괄호 외부의 것들은 중괄호 내부의 것들의 전역상태로 간주됨
- 내부 변수에 외부 데이터를 할당한 경우, 누군가 외부 데이터를 읽거나 변경할 수 있어서 데이터가 손상될 수 있음
- 코드에서 상태를 명시적으로 확인하지 않는 속성을 **불변속성(invariant)**이라고함
- 불변속성이 잘 유지되기는 힘듦
- 불변속성의 범위제한 - `함께 변하는 것은 함께 있어야 한다` 을 적용할 수 있음

#### 코드가 하는 일을 바꾸지 않고 유지보수하기

- 값을 입력하면 리팩터링 전과 후에 동일한 결과를 얻어야함
- 코드가 수행하는 작업이 변경되지는 않지만, 성능은 바꿀 수 있음
- 대부분 가독성과 유지보수성이 성능보다 가치있으므로 코드가 느려져도 거의 신경 쓰지 않음
- 성능이 중요한 경우에는 리팩터링과 다른 단계에서 처리해야함

**리팩터링의 핵심**

1. 의도를 전달함으로써 가독성 향상
2. 불변속성의 범위제한을 통한 유지보수성 향상
3. 범위 밖의 코드에 영향을 주지 않고 1항과 2항을 수행

### 속도, 유연성 및 안정성 확보

#### 상속보다는 컴포지션 사용

- `상속`은 범위가 제한되지 않은 불변속성을 도입하는 일반적인 방법
- 상속보다 `컴포지션` 사용이 권장됨
- 대부분의 리팩터링 패턴과 규칙은 `객체 컴포지션`을 돕기 위한 것
- => 객체가 내부에 다른 객체의 참조를 가지는 것

상속 예제

```ts
interface Bird {
    ...
}

class CommonBird implements Bird {
    ...
}

class Penguin extends CommonBird {
    canFly() { return false; }
}
```

컴포지션 예제

```ts
interface Bird {
    ...
}

class CommonBird implements Bird {
    ...
}

class Penguin implements Bird {
    private bird = new CommonBird() // 컴포지션
    hasBeak() { return bird.hasBeak(); } // 호출을 직접 명시적으로 전달해야함
    canFly() { return false; }
}
```

- Bird에 canSwim()이라는 메서드가 추가되고, Penguin은 다른 새와 달리 날지 못한다면 canSwim() 메서드를 Penguin 클래스에서 재정의(override) 해야하는데, 이는 작업자가 기억해야하는 내용이므로 취약함
- 유연성이 좋아서 코드를 결합하고 재사용하는데 용이함
- 컴포지션의 가장 큰 장점은 `추가`로 변경이 가능한 것
- 기존 기능에 영향을 주지 않고 기능을 추가하거나 변경할 수 있음 (개방-폐쇄 원칙)
- 사용하지 않는 코드는 최대한 빨리 삭제하는 것이 좋음
- 추가를 통해 변경하게되면 기존 코드에 오류가 발생하지 않게하여 시스템의 안정성을 향상시킬 수 있음

### 리팩터링과 일상 업무

- 리팩터링을 하지 않는 등 여러 부정적인 요인들로 인해 소프트웨어 아키텍처에 이자가 붙는데, 이를 `기술 부채`라고함
- 레거시 시스템에서는 변경하기 전에 리팩터링 하라
- 코드를 변경한 후에도 리팩터링 하라
- 항상 여러분이 왔을 때보다 더 좋게 만들어 놓고 떠나세요

### 소프트웨어 분야에서 '도메인' 정의하기

- 이 실제 세계의 구성요소를 소프트웨어의 **도메인**이라고함
- 도메인에는 흔히 사용자, 전문가, 고유한 용어, 고유한 문화가 있음
- 소프트웨어를 개발할 때는 도메인 전문가들의 용어와 문화를 배워야함
- 프로그래밍은 주호 학습과 의사소통에 관한 것

### 요약

- 리팩터링은 기능 변경 없이 코드의 의도를 전달하고 불변속성의 범위를 제한하는 것
- 상속보다 컴포지션을 사용함으로써 추가를 통한 변경으로 개발 속도, 유연성, 안정성을 확보할 수 있음
- 리팩터링을 일상 업무에 포함시켜 기술 부채가 쌓이지 않도록 해야함
- 리팩터링을 연습하면 코드에 대한 독특한 관점을 얻을 수 잇으며, 이로 인해 더 나은 해결책을 찾을 수 있음
