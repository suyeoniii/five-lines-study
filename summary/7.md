# 7장 컴파일러와의 협업

- 컴파일러의 장단점 이해
- 컴파일러의 장점을 활용한 불변속성 제거
- 컴파일러와 책임 분담

### 컴파일러에 대해 알아보기

- 일반적으로 하나를 여러번 컴파일한다고 다른 결과가 나오지 않음
- 판단과 같은 특정 작업에는 약한 편 => 컴파일러는 문법 오류외에 어떠한 판단을 내리지는 않음. 판단은 런타임에 이루어짐
- '의심가면 물어보라'는 일반적인 관용구를 따름 => 디버깅을 통해 확인해봐야함
- 컴파일러의 목표는 다른 언어로된 동일한 프로그램을 만드는 것

#### 약점: 정지 문제는 컴파일 시 알 수 있는 것을 제한한다

- `정지문제`: 일반적으로 프로그램은 근본적으로 예측이 불가능함
- 프로그램을 실행하지 않고는 프로그램이 어떻게 동작할지 알 수 없음
- 어떤 컴파일러는 실행 불가능한 코드를 허용하지 않지만, 허용하는 컴파일러도 있음
- 정지문제는 컴파일러가 이 둘 사이에서 프로그램을 어떻게 할 것인지 결정해야 하는 것을 의미함
- `보수적 분석`: 프로그램이 안전하다고 보장할 수 없는 경우 컴파일러가 프로그램을 허용하지 않는 것
- 보수적 분석은 프로그램에 특정 실패 가능성이 없다는 것을 보증하므로, 보수적 분석에 의존할 수 있음

```ts
if(new Date().getDay() === 35){ // true 일 수 없는 코드
    5.foo() // 런타임 오류가 발생하는 코드
}
```

#### 장점: 도달성 검증은 메서드의 반환을 보장한다

- 보수적인 분석 중 하나는 `메서드가 모든 경우에서 반환되는지` 확인하는 것
- return 문 없이 메서드를 벗어나는 것은 허락되지 않음

#### 장점: 확정 할당은 초기화되지 않은 변수에 대한 접근을 막는다

- 컴파일러는 변수가 사용되기 전에 `변수에 값이 확실히 할당되었는지` 여부를 알아냄
- 예제 코드에서는 result가 초기화된다는 보장이 없으므로 허용되지 않음
- 배열에 John이라는 값이 무조건 들어있음을 보장하고 싶으면 읽기전용(또는 final) 필드를 사용해서 생성자 또는 선언 시 할당하여 컴파일러에게 알릴 수 있음

```ts
let result;
for (let i = 0; i < arr.length; i++) {
  if (arr[i].name === "John") result = arr[i];
}
return result; // result가 초기화된다는 보장이 없음 -> 오류
```

#### 장점: 접근 제어로 데이터 캡슐화를 지원한다

- private을 적용하면 외부에서 사용할 수 없음

#### 장점: 타입(형) 검사기는 속성을 보증한다

- 변수와 멤버가 존재하는지 확인
- 순서 강제화에서 사용한 것도 타입검사

#### 약점: null을 역참조하면 애플리케이션이 손상된다

- null로 메서드 호출 시 오류 발생
- 타입스크립트에서는 엄격한 null 검사 여부를 on/off 할 수 있음
- 엄격한 null 검사를 하도록 해야함

#### 약점: 산술 오류는 오버플로나 손상을 일으킨다

- 컴파일러는 0으로 나누기 또는 나머지 연산을 확인하지 않음
- 오버플로 될 수 있는지도 확인하지 않음
- 이와 같은 산술 연산 시 나누는 수가 0이 되는지, 오버플로 언더플로 같은 큰 숫자를 더하거나 빼는지 확인하고, 큰 숫자를 다룰 경우 BigInteger 등을 사용하기

#### 약점: 아웃-오브-바운드 오류는 애플리케이션을 손상시킨다

- 범위 내에 있지 않은 인덱스에 접근하려고 하는 경우
- 앞에 나온 확정할당 (읽기 전용으로 바꾸고 초기화 하는 것)하는 방법을 사용할 수 있음

```ts
function firstPrime(arr: number[]) {
  return arr[indexOfPrime(arr)]; // 배열에 소수가 없는 경우 -1 접근
}
```

#### 무한루프는 애플리케이션을 지연시킨다

- 무한루프는 대부분 컴파일러에 의해 감지되지 않음
- forEach, stream 등 높은 수준의 구성으로 전환되며 문제 감소중

```ts
let insideQuote = false;
let quotePosition = s.indexOf('"');
// s에 따옴표가 포함된 경우 무한루프
while (quotePosition >= 0) {
  insideQuote = insideQuote;
  quotePosition = s.indexOf('"');
}
```

#### 약점: 교착 상태 및 경쟁 강태로 인해 의도하지 않은 동작이 발생한다

- 멀티스레딩을 통해 `경쟁 상태, 교착 상태, 기아` 등의 문제가 발생핳 수 있음
- 경쟁 상태

  - 두 개 이상의 스레드가 공유하는 변수를 읽고 쓰기 위해 경쟁할 때 발생
  - 두 스레드가 변수를 업데이트하기 위해 동일한 값을 읽어옴
  - 해결방법: Lock 도입 - 진행 하기 전에 스레드에 잠금을 부여하고 다른 스레드의 잠금이 해제되었는지 확인
  - 두 스레드가 모두 잠겨있고 계속 진행하기 전에 서로 잠금해제를 기다리고 있음 (교착 상태)

  ```ts
   class Counter implements Runnable {
       private status number = 0;
       constructor(
           private mine: Lock, private other: Lock) {}
       run() {
           for(let i = 0; i < 10; i++){
               mine.lock(); // 해당 스레드 lock 설정
               other.waitFor(); // 다른 스레드는 대기
               console.log(this.number++) // 작업
               mine.free() // 스레드 lock 해제
           }
       }
   }

   let aLock = new Lock();
   let bLock = new Lock()
   let a = new Thread(new Counter(aLock, bLock))
   let b = new Thread(new Counter(bLock, aLock))
   a.start()
   b.start()
  ```

- 기아 상태

  - 한쪽이 기다리고 있는 상태에서 반대편 차가 멈추지 않고 이어져서 갈 수 없는 상황

  ```ts
  class Printer implements Runnable {
      constructor(
          private name: string
          private mine: Lock, private other: Lock) {}
      run() {
        while(true) {
            other.waitFor();
            mine.lock()
            console.log(this.name)
            mine.free()
        }
      }
  }

  let a = new Thread(new Printer("A", aLock, bLock));
  let b = new Thread(new Printer("B", bLock, aLock));
  a.start()
  b.start()
  ```

- -> 변경 가능한 데이터를 공유하는 다중 스레드를 사용하지 말 것

### 컴파일러 사용

#### 컴파일러 활용

- 컴파일러를 TODO 리스트로 사용해 안전성을 확보
  - 오류를 발생시켜서 해결해야할 부분을 TODO 리스트인 것처럼 사용
- 순서 강제화를 이용한 안전성 확보
  - 불변속성을 컴파일러에게 알려줌
  - 예를들어 생성자를 이용해서 문자열을 대문자로 만들어서 특정 변수가 항상 대문자임을 알림
- 캡슐화 강제를 통한 안전성 확보
  - 접근 제어를 통해 데이터를 기대하는 형태로 유지시킴
- 컴파일러로 사용하지 않는 코드 감지
  - 코드 `삭제 후 컴파일`하여 오류가 없는지 확인 하는 것을 통해 사용하지 않는 코드 감지
- 확정 값을 통한 안전성 확보
  - 확정 할당을 통해 변수의 특정 값을 보장 (비어있을 수 없는 배열, 특정 값이 존재하는 배열 등)

#### 컴파일러와 싸우지 말 것

- 컴파일러가 제 역할을 못하도록 막지 않을 것
- **타입** 검사기는 컴파일러의 가장 강력한 부분. 타입 검사기를 무력화 시키는 방법
  - **형 변환**: 형 변환은 컴파일러에게 컴파일러보다 자신이 더 잘 알고 있다고 말하는 것
  - **동적 타입**: 타입 검사를 비활성화 시킴 - 동적 유형의 타입을 통해 (any)
  - **런타임 타입**: 컴파일 시간에 런타임으로 판단에 필요한 정보를 옮기는 것 (특정 개수 배열의 타입으로 Map을 사용하는 것 -> 아웃오브바운드 오류 발생 가능)
- **기본값**: 기본값을 넣지않으면 컴파일러가 발견할 수 있으므로 이상한 값을 사용하는 것을 방지할 수 있음. 기본값을 넣으면 컴파일러의 도움을 받지 못함
- **상속**: 인터페이스에서만 상속받을 것. 클래스로 상속받으면 자손 클래스에서 메서드가 수동으로 유효한지 확인해야함. 인터페이스는 메서드를 자손클래스에서도 구현해야하므로 구현하지 않으면 컴파일러에 의해 발견됨
- **처리를 강제하지 않은 예외**: 발생할 수 없는 예외에 대해서만 `처리를 강제하지 않은 예외`를 발생시키고, 발생할 수 있는 예외에 대해서는 `처리된 예외`를 발생시켜야함
- **아키텍처**
  - 주로 마이크로 아키텍처에 대한 이해가 부족하기때문
  - 마이크로 아키텍처는 팀에 영향을 미치지만 다른 팀에 영향을 미치지 않음
  - 주로 getter, setter를 허용하는 경우 외부에서 값을 수정할 수 잇으므로 문제가됨

### 컴파일러 신뢰하기

#### 컴파일러에게 불변속성 가르치기

- 지역 불변속성

#### 컴파일러의 경고에 주의를 기울일 것

### 컴파일러만 신뢰할 것

### 요약
